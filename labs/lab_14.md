# Lab 14

*Lab 14 GitHub Classroom link:* https://classroom.github.com/a/g4N-mzQX

In this lab, we will learn how to create and manipulate Python containers, how to use for-loops with containers, and how to pass arguments to a Python script through Unix.

1. If statements
2. For-loops
3. Script arguments

To begin this lab, clone your GitHub assignment repository to your virtual machine, enter the newly cloned directory, then open the `ipython` command line interface.

---

### If-statements

If-statements are used to execute a block of code *only if* a condition is met. Python if-statements have two major features: the condition statements and each condition's code block. Python will only execute the code block for the first condition that evaluates as `True` (bool) in a standard if-statement. All if-statements begin with an `if` condition. They can be followed by zero or more else-if (`elif`) blocks. These blocks are only executed if the condition is met *and* no previous conditions evaluate as `True`. They can also be terminated with zero or one `else` blocks. The else block is executed only if no previous conditions evaluate as `True`.

```python
a = 3
b = 2
if a > b:
    print('a > b')
elif a >= b:
    print('a >= b') 
elif a == b:
    print('a == b')
else:
    print('a < b')
```
Notice that the first condition (`a > b`) would test for "greater than" before attempting the second condition (`a >= b`), therefore we don't expect the second block to run unless `a==b`. However, if that was `True`, the third condition (`a==b`) would not be run. The fourth condition (`a < b`) is run if the first three conditions evaluate as `False`.

You can also construct simpler if-statement blocks, as needed, such as
```python
a = 3
b = 2
if a > b:
    print('a > b')
```

and 

```python
a = 3
b = 2
if a > b:
    print('a > b')
elif a < b:
    print('a < b') 
```

or

```python
a = 3
b = 2
if a > b:
    print('a > b')
else:
    print('a <= b')
```

---

## For-loops

For-loops are often used to apply a general code subroutine to all elements in a container. To accomplish this, for-loops can be designed to *iterate* over all elements in a container, using a temporary variable (called an *iterator*) to represent an element's value, then applying a *code block* for each iteration. For-loops in Python work very similarly to how they behave in Unix, but the syntax is different. Python for-loops may also be defined in various ways, depending on what container type you're working with and what code block you want to execute during iteration. We'll explore several for-loop architectures that are commonly used with lists and dictionaries.

For-loops in Python have the same general syntax, being
```python
[MAIN CODE]
for [ITERATOR(S)] in [ITERABLES]:
    [CODE BLOCK] using [ITERATOR(S)]
    ...
 
[MAIN CODE]
```
Note that the code block executed during each iteration (`[CODE BLOCK]`) is made distinct from the main code (`[MAIN CODE]`) through indented whitespace.

Perhaps the simplest for-loop involves directly iterating over the elements of a container
```python
In [1]: x = ['a', 'b', 'c']

In [2]: for i in x:
   ...:     print(i)
   ...:
a
b
c
```

An alternative is to use the `range(n)` function, which generates a list of integers, `[0, 1, ..., n-1]`. When iterating over `range(n)`, the iterator can then be used to index a list with `n` elements.

```python
In [1]: x = ['a', 'b', 'c']

In [2]: n = len(x)

In [3]: for i in range(n):
   ...:     print(i, x[i])
   ...:
0 a
1 b
2 c
```

When iterating over elements, sometimes it's useful to know how many times your loop has iterated. Using `enumerate(x)` on the container `x` will produce a list of paired values, where the first element is the iteration counter, and the second element is the iterator value

```python
In [1]: x = ['a', 'b', 'c']

In [2]: for i,v in enumerate(x):
   ...:     print(i,v)
   ...:
0 a
1 b
2 c

```

When iterating over elements in a dictionary, iterators will be equal to the value of the dictionary's keys. Those keys can then be used to index each value in the dictionary.

```python
In [1]: x = { 'a':10, 'b':20, 'c':30 }

In [2]: for k in x:
   ...:     print(k, x[k])
   ...:
a 10
b 20
c 30
```

We can also iterate over key-value *tuples* for a dictionary -- e.g. `(k,v)`. To do so, generate the container of key-value tuples with `x.items()`, then pass those iterables to the for-loop.

```python
In [1]: x = { 'a':10, 'b':20, 'c':30 }

In [2]: for k,v in x.items():
   ...:     print(k,v)
   ...:
a 10
b 20
c 30
```

As with lists, `enumerate` can be applied to dictionaries. In the below example, counter generated by `enumerate` becomes the first element in the tuple, and the key-value pair becomes the second tuple value (where the key-value pair is itself a tuple, nested within another tuple).

```python
In [1]: x = { 'a':10, 'b':20, 'c':30 }
In [2]: for i,(k,v) in enumerate(x.items()):
   ...:     print(i,k,v)
   ...:
0 a 10
1 b 20
2 c 30
```

For-loops can be nested with other control structures, including other for-loops and if-statements

```python
In [1]: x = [[1,2],[3,4]]
In [2]: for i in x:
   ...:   for j in i:
   ...:     if j % 2 == 0:
   ...:       print( str(j) + ' is even' )
   ...:     else:
   ...:       print( str(j) + ' is odd' )
   ...:
1 is odd
2 is even
3 is odd
4 is even
```

Below is another example, which only assigns values to new keys in a dictionary. This prevents old keys from being overwritten with new values.

```python
>>> d = {'dog' : 'woof'}
>>> 'dog' in d
True
>>> 'woof' in d
False
>>> animals = ['cat', 'dog']
>>> sounds = ['meow', 'ruff']
>>> for i in range(len(sounds)):
...     if animals[i] not in d:
...         d[animals[i]] = sounds[i]
...
>>> d
{'dog': 'woof', 'cat': 'meow'}
```



---

## Script arguments

In the previous lab, we hardcoded user input as variables within the Python script. This is less than ideal, because it would require potential users of the script to modify the Python code, which may be beyond a user's comfort level and/or compromise the integrity of the script itself. One way that Python scripts can accept user-defined input is through the *system argument vector* container, called `sys.argv`. The `sys.argv` variable is a list that captures the context of the operating system call in which the Python script was executed.

To understand how `sys.argv` works, create a Python script called `example.py` with the following content
```console
#!/usr/bin/python
import sys      # load a special library that defines sys.argv behavior
print('Contents of sys.argv, length = ' + str(len(sys.argv)))
for i,x in enumerate(sys.argv):
    print( '  sys.argv['+str(i)+'] = ' + sys.argv[i])
```

then, return to the Unix shell, enable execute-permissions for the `example.py`, then execute the script while passing several arguments

```
$ chmod +x example.py
$ ./example.py hello world 3.14
Contents of sys.argv, length = 4
  sys.argv[0] = ./example.py
  sys.argv[1] = hello
  sys.argv[2] = world
  sys.argv[3] = 3.14
```

Study the content of `example.py` to understand how to access `sys.argv` elements by index.


---

## Exercises

You will create a separate Python script for each of the following problems. Name the script after which problem it solves, e.g. `problem1.py`.

**Problem 1.** Write a Python script that summarizes information for the following matrix, represented as a list (rows) of lists (columns).

```
x = [ ['a', 'g', 'a', 't', 'c', 'g', 'a'],
      ['a', 'g', 'a', 'a', 'c', 'g', 'a'],
      ['c', 'a', 'a', 't', 'c', 'g', 'a'],
      ['a', 'g', 'a', 'a', 'c', 'g', 'a'],
      ['a', 't', 'g', 'c', 'c', 'g', 'a'],
      ['t', 'g', 'a', 'a', 'c', 'g', 'a'],
      ['c', 'c', 'a', 'c', 'c', 'g', 'a'] ]
```

For the four nucleotides ('a', 'c', 'g', and 't'), each in turn, print out all row-column index pairs that correspond to a given nucleotide. For example, the output for nucleotide `t` would appear as
```
't' : (0,3), (2,3), (4,1), (5,0)
```

This problem can be solved in multiple ways. One way is to use three nested for-loops, with an if-statement in the innermost loop.

**Problem 2.** Write a Python script that prints all integers between the values of 1 and 100 that are evenly divisible by 2 but are *not* divisible by 3. The easiest way to solve this problem will use a for-loop, 1 or 2 if-statements, and the modulus (`%`) operator.

**Problem 3.** Write a Python script that converts a sequence of numbers into a sequence of alphabetical characters. The script expects any number of integers (valued 1 to 26) as an argument. Taking each number in the arguments, the script then converts that number into the letter in the corresponding position in the alphabet. For example, if the script was called as `./problem3.py 3 1 20` would print `cat`, and `./problem3.py 16 25 20 8 15 14` would print `python`.

To complete the lab, commit and push your three scripts and a log of your history to your GitHub repository.

